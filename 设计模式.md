# 一种模式
- 先判断, 判断成功在执行, 只需要处理成功的情况
- 直接执行, 返回是否执行成功, 分别处理成功和失败的情况
- 开放-封闭原则：类应该对扩展开放，对修改封闭

## 设计原则
- 封装变化
- 针对接口编程
- 多用组合，少用继承

## 设计模式
### 结构型
- 适配器（adapter）：将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
- 装饰（decorator）：动态地给一个对象添加一些额外的指责。
- 外观（facade）：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
- 享元（flyweight）：运用共享技术有效地支持大量细粒度的对象
- 代理（proxy）：为其他对象提供一种代理以控制对这个对象的访问

### 行为模式
- 策略模式：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户
- 观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新
  - 一对多 or 多对多
  - 推数据 or 拉数据
- 职责链（chain of responsibility）模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止
- 备忘录（memento）模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
- 迭代器（iterator）模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示



- 解释器（Interpreter）模式: